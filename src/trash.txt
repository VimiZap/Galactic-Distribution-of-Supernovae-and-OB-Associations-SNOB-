def axisymmetric_disk_model_2(N, r_s, h):
    """
    N: number of stars
    r_s: distance from the Sun to the Galactic center
    h: scale-length of the disk
    """
    r = np.random.exponential(h, N) # random numbers from the exponential distribution
    theta = np.random.uniform(0, 2*np.pi, N) # random numbers from the uniform distribution
    x = r*np.cos(theta) + r_s # x coordinates of the stars
    y = r*np.sin(theta) # y coordinates of the stars
    return x, y

def total_integrand_axisymmetric(b,r,l):
    const = total_galactic_n_luminosity / (a_d * 4 * np.pi * np.radians(1) * np.sqrt(2*np.pi) * sigma)
    return const * np.exp(-0.5 * (r*np.sin(b)/sigma)**2) * np.exp((-np.sqrt((r * np.cos(b))**2 + r_s ** 2 - 2*r_s*np.cos(b)*np.cos(l)))/h) * np.cos(b)

def total_integral_axisymmetric(l):
    lat_lim = np.radians(3.5)
    return dblquad(total_integrand_axisymmetric, 0, r_max, -lat_lim, lat_lim, args=(l,))

def vectorized_total_integral_axisymmetric(l):
    return np.vectorize(total_integral_axisymmetric)(l)

def integral_axisymmetric(l): # integrate over the radial distance and the latitude
    lat_lim = np.radians(3.5)
    return dblquad(integrand_axisymmetric, 0, r_max, -lat_lim, lat_lim, args=(l,))


def vectorized_integral_axisymmetric(l): # vectorize the function integral_axisymmetric
    return np.vectorize(integral_axisymmetric)(l)


def generate_transverse_points(arm_medians, transverse_distances):
    """
    Args:
        arm_medians: array of distances \rho to the arm median
    Returns:
        a matrix of transverse points (rho's) for the spiral arm
    """
    # for each point in arm_medians, generate the transverse points
    transverse = []
    for arm_median in arm_medians:
        transverse_points = arm_median - transverse_distances
        transverse_points = np.append(transverse_points, arm_median + transverse_distances)
        transverse.append(transverse_points)
    return np.array(transverse) 
    
def plot_spiral_arms():
    """
    Plots the spiral arms
    """
    transverse_distances, transverse_densities = generate_non_uniform_spacing(d_min=0.01) #d_min: minimum distance from the spiral arm
    for i in range(len(arm_angles)):
        theta, rho = spiral_arm_medians(arm_angles[i], pitch_angles[i])
        x = rho*np.cos(theta)
        y = rho*np.sin(theta)
        plt.plot(x, y)
        transverse = generate_transverse_points(rho, transverse_distances)
        for j in range(len(transverse)):
            rotation_point = (rho[j]*np.cos(theta[j]), rho[j]*np.sin(theta[j]))
            x, y = transverse[j]*np.cos(theta[j]), transverse[j]*np.sin(theta[j])
            rotated_points = rotate_point(np.array([x,y]).T, np.radians(pitch_angles[i]), rotation_point)
            plt.scatter(rotated_points[:, 0], rotated_points[:, 1])
    plt.gca().set_aspect('equal')
    plt.savefig("output/spiral_arms_w_transverse_contribution.png")  # save plot in the output folder
    plt.show()